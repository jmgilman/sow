package cmd

import (
	"fmt"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"time"

	"github.com/jmgilman/sow/cli/internal/cmdutil"
	"github.com/jmgilman/sow/cli/internal/sdks/project/state"
	"github.com/jmgilman/sow/cli/internal/sow"
	"github.com/jmgilman/sow/libs/schemas/project"
	"github.com/spf13/cobra"
)

// NewTaskCmd creates the task command.
func NewTaskCmd() *cobra.Command {
	cmd := &cobra.Command{
		Use:   "task",
		Short: "Manage project tasks",
		Long: `Manage project tasks.

Task commands allow you to create, modify, and list tasks within project phases.
Tasks are the atomic units of work, each with inputs, outputs, and status tracking.`,
	}

	cmd.AddCommand(newTaskAddCmd())
	cmd.AddCommand(newTaskSetCmd())
	cmd.AddCommand(newTaskAbandonCmd())
	cmd.AddCommand(newTaskStatusCmd())
	cmd.AddCommand(newTaskInputCmd())
	cmd.AddCommand(newTaskOutputCmd())

	return cmd
}

// newTaskAddCmd creates the task add subcommand.
func newTaskAddCmd() *cobra.Command {
	var agent, description, taskID, phase string

	cmd := &cobra.Command{
		Use:   "add <name>",
		Short: "Add a new task",
		Long: `Add a new task to the specified phase.

Creates a new task with a gap-numbered ID (010, 020, 030...) and initializes
the task directory structure:
  - description.md (from --description or placeholder)
  - log.md (empty template)
  - feedback/ (empty directory)

The task ID is auto-generated by default, but can be specified with --id.

Phase Support:
  Not all phases support tasks. Use --phase to specify which phase, or let
  the command choose a smart default based on current project state.

Examples:
  # Add task with agent and description (auto-generated ID, default phase)
  sow task add "Implement JWT signing" --agent implementer --description "Create RS256 signing"

  # Add task to specific phase
  sow task add "Implement JWT signing" --agent implementer --phase implementation

  # Add task with specific ID
  sow task add "Implement JWT signing" --agent implementer --id 010`,
		Args: cobra.ExactArgs(1),
		RunE: func(cmd *cobra.Command, args []string) error {
			return runTaskAdd(cmd, args[0], agent, description, taskID, phase)
		},
	}

	cmd.Flags().StringVar(&agent, "agent", "", "Agent type to assign (required)")
	cmd.Flags().StringVar(&description, "description", "", "Task description")
	cmd.Flags().StringVar(&taskID, "id", "", "Task ID (optional, auto-generated if not specified)")
	cmd.Flags().StringVar(&phase, "phase", "", "Target phase (defaults to current phase)")

	_ = cmd.MarkFlagRequired("agent")

	return cmd
}

// newTaskSetCmd creates the task set subcommand.
func newTaskSetCmd() *cobra.Command {
	var taskID, phase string

	cmd := &cobra.Command{
		Use:   "set <field-path> <value>",
		Short: "Set task field value",
		Long: `Set a task field value using dot notation.

Supports:
  - Direct fields: status, iteration, assigned_agent, name
  - Metadata fields: metadata.* (any custom field)

Examples:
  # Set status
  sow task set --id 010 status completed

  # Set iteration
  sow task set --id 010 iteration 2

  # Set metadata field
  sow task set --id 010 metadata.complexity high

  # Set field in specific phase
  sow task set --id 010 --phase implementation status in_progress`,
		Args: cobra.ExactArgs(2),
		RunE: func(cmd *cobra.Command, args []string) error {
			return runTaskSet(cmd, args, taskID, phase)
		},
	}

	cmd.Flags().StringVar(&taskID, "id", "", "Task ID (required)")
	cmd.Flags().StringVar(&phase, "phase", "", "Target phase (defaults to current phase)")
	_ = cmd.MarkFlagRequired("id")

	return cmd
}

// newTaskAbandonCmd creates the task abandon subcommand.
func newTaskAbandonCmd() *cobra.Command {
	var taskID, phase string

	cmd := &cobra.Command{
		Use:   "abandon",
		Short: "Abandon a task",
		Long: `Mark a task as abandoned.

Sets the task status to "abandoned" and sets the completed_at timestamp.

Examples:
  # Abandon task (default phase)
  sow task abandon --id 010

  # Abandon task in specific phase
  sow task abandon --id 010 --phase implementation`,
		RunE: func(cmd *cobra.Command, _ []string) error {
			return runTaskAbandon(cmd, taskID, phase)
		},
	}

	cmd.Flags().StringVar(&taskID, "id", "", "Task ID (required)")
	cmd.Flags().StringVar(&phase, "phase", "", "Target phase (defaults to current phase)")
	_ = cmd.MarkFlagRequired("id")

	return cmd
}

// newTaskStatusCmd creates the task status subcommand.
func newTaskStatusCmd() *cobra.Command {
	var taskID, phase string

	cmd := &cobra.Command{
		Use:   "status",
		Short: "Show task status",
		Long: `Show task status - either overview of all tasks or detailed info about a specific task.

Without --id flag: Shows overview of all tasks in the specified phase (or default phase)
With --id flag: Shows detailed information about a specific task including inputs, outputs, and metadata

Examples:
  # Show overview of all tasks (default phase)
  sow task status

  # Show overview of tasks in specific phase
  sow task status --phase implementation

  # Show detailed information about task 010
  sow task status --id 010

  # Show task in specific phase
  sow task status --id 010 --phase implementation`,
		RunE: func(cmd *cobra.Command, _ []string) error {
			return runTaskStatus(cmd, taskID, phase)
		},
	}

	cmd.Flags().StringVar(&taskID, "id", "", "Task ID for detailed view (optional)")
	cmd.Flags().StringVar(&phase, "phase", "", "Target phase (defaults to current phase)")

	return cmd
}

// runTaskAdd implements the task add command logic.
func runTaskAdd(cmd *cobra.Command, name, agent, description, taskID, explicitPhase string) error {
	ctx := cmdutil.GetContext(cmd.Context())

	// Check if sow is initialized
	if !ctx.IsInitialized() {
		return fmt.Errorf("sow not initialized. Run 'sow init' first")
	}

	// Load project
	proj, err := state.Load(ctx)
	if err != nil {
		if strings.Contains(err.Error(), "no such file") {
			return fmt.Errorf("no active project found")
		}
		return fmt.Errorf("failed to load project: %w", err)
	}

	// Resolve which phase to use
	phaseName, err := resolveTaskPhase(proj, explicitPhase)
	if err != nil {
		return err
	}

	// Get phase
	phaseState, exists := proj.Phases[phaseName]
	if !exists {
		return fmt.Errorf("phase not found: %s", phaseName)
	}

	// Generate or validate task ID
	if taskID == "" {
		// Auto-generate next task ID (gap-numbered)
		taskID = generateNextTaskID(phaseState.Tasks)
	} else {
		// Validate specified task ID format (must be 3 digits)
		if len(taskID) != 3 {
			return fmt.Errorf("task ID must be 3 digits (e.g., 010, 020)")
		}
		if _, err := strconv.Atoi(taskID); err != nil {
			return fmt.Errorf("task ID must be numeric: %w", err)
		}

		// Check for duplicate task ID
		for _, task := range phaseState.Tasks {
			if task.Id == taskID {
				return fmt.Errorf("task ID %s already exists", taskID)
			}
		}
	}

	// Create task
	now := time.Now()
	task := project.TaskState{
		Id:             taskID,
		Name:           name,
		Phase:          phaseName,
		Status:         "pending",
		Iteration:      1,
		Assigned_agent: agent,
		Created_at:     now,
		Updated_at:     now,
		Inputs:         []project.ArtifactState{},
		Outputs:        []project.ArtifactState{},
		Metadata:       make(map[string]interface{}),
	}

	// Add to phase tasks
	phaseState.Tasks = append(phaseState.Tasks, task)
	proj.Phases[phaseName] = phaseState

	// Create task directory
	if err := createTaskDirectory(ctx, phaseName, taskID, description); err != nil {
		return fmt.Errorf("failed to create task directory: %w", err)
	}

	// Save project state
	if err := proj.Save(); err != nil {
		return fmt.Errorf("failed to save project: %w", err)
	}

	fmt.Printf("Added task [%s] %s to phase %s\n", taskID, name, phaseName)
	return nil
}

// runTaskSet implements the task set command logic.
func runTaskSet(cmd *cobra.Command, args []string, taskID, explicitPhase string) error {
	ctx := cmdutil.GetContext(cmd.Context())

	// Check if sow is initialized
	if !ctx.IsInitialized() {
		return fmt.Errorf("sow not initialized. Run 'sow init' first")
	}

	// Load project
	proj, err := state.Load(ctx)
	if err != nil {
		if strings.Contains(err.Error(), "no such file") {
			return fmt.Errorf("no active project found")
		}
		return fmt.Errorf("failed to load project: %w", err)
	}

	// Resolve which phase to use
	phaseName, err := resolveTaskPhase(proj, explicitPhase)
	if err != nil {
		return err
	}

	// Get phase
	phaseState, exists := proj.Phases[phaseName]
	if !exists {
		return fmt.Errorf("phase not found: %s", phaseName)
	}

	// Find task by ID
	taskIndex := -1
	for i, t := range phaseState.Tasks {
		if t.Id == taskID {
			taskIndex = i
			break
		}
	}

	if taskIndex == -1 {
		return fmt.Errorf("task not found: %s", taskID)
	}

	// Wrap in Task type for field path mutation
	task := &state.Task{
		TaskState: phaseState.Tasks[taskIndex],
	}

	// Set field using field path parser
	fieldPath := args[0]
	value := args[1]

	if err := cmdutil.SetField(task, fieldPath, value); err != nil {
		return fmt.Errorf("failed to set field: %w", err)
	}

	// Update task's updated_at timestamp
	task.Updated_at = time.Now()

	// Update back in phase
	phaseState.Tasks[taskIndex] = task.TaskState
	proj.Phases[phaseName] = phaseState

	// Save project state
	if err := proj.Save(); err != nil {
		return fmt.Errorf("failed to save project: %w", err)
	}

	fmt.Printf("Set %s on task [%s] in phase %s\n", fieldPath, taskID, phaseName)
	return nil
}

// runTaskAbandon implements the task abandon command logic.
func runTaskAbandon(cmd *cobra.Command, taskID, explicitPhase string) error {
	ctx := cmdutil.GetContext(cmd.Context())

	// Check if sow is initialized
	if !ctx.IsInitialized() {
		return fmt.Errorf("sow not initialized. Run 'sow init' first")
	}

	// Load project
	proj, err := state.Load(ctx)
	if err != nil {
		if strings.Contains(err.Error(), "no such file") {
			return fmt.Errorf("no active project found")
		}
		return fmt.Errorf("failed to load project: %w", err)
	}

	// Resolve which phase to use
	phaseName, err := resolveTaskPhase(proj, explicitPhase)
	if err != nil {
		return err
	}

	// Get phase
	phaseState, exists := proj.Phases[phaseName]
	if !exists {
		return fmt.Errorf("phase not found: %s", phaseName)
	}

	// Find task by ID
	taskIndex := -1
	for i, t := range phaseState.Tasks {
		if t.Id == taskID {
			taskIndex = i
			break
		}
	}

	if taskIndex == -1 {
		return fmt.Errorf("task not found: %s", taskID)
	}

	// Update task status
	now := time.Now()
	phaseState.Tasks[taskIndex].Status = "abandoned"
	phaseState.Tasks[taskIndex].Completed_at = now
	phaseState.Tasks[taskIndex].Updated_at = now

	proj.Phases[phaseName] = phaseState

	// Save project state
	if err := proj.Save(); err != nil {
		return fmt.Errorf("failed to save project: %w", err)
	}

	fmt.Printf("Abandoned task [%s] in phase %s\n", taskID, phaseName)
	return nil
}

// runTaskStatus implements the task status command logic.
func runTaskStatus(cmd *cobra.Command, taskID, explicitPhase string) error {
	ctx := cmdutil.GetContext(cmd.Context())

	// Check if sow is initialized
	if !ctx.IsInitialized() {
		return fmt.Errorf("sow not initialized. Run 'sow init' first")
	}

	// Load project
	proj, err := state.Load(ctx)
	if err != nil {
		if strings.Contains(err.Error(), "no such file") {
			return fmt.Errorf("no active project found")
		}
		return fmt.Errorf("failed to load project: %w", err)
	}

	// Resolve which phase to use
	phaseName, err := resolveTaskPhase(proj, explicitPhase)
	if err != nil {
		return err
	}

	// Get phase
	phaseState, exists := proj.Phases[phaseName]
	if !exists {
		return fmt.Errorf("phase not found: %s", phaseName)
	}

	// Check if overview or detailed mode
	if taskID == "" {
		// Overview mode - show all tasks
		return displayTaskOverview(phaseName, phaseState.Tasks)
	}

	// Detailed mode - find and display specific task
	for _, task := range phaseState.Tasks {
		if task.Id == taskID {
			return displayTaskDetail(task)
		}
	}

	return fmt.Errorf("task [%s] not found in phase %s", taskID, phaseName)
}

// displayTaskOverview shows an overview of all tasks.
func displayTaskOverview(phaseName string, tasks []project.TaskState) error {
	if len(tasks) == 0 {
		fmt.Printf("No tasks found in phase %s.\n", phaseName)
		return nil
	}

	fmt.Printf("Tasks in %s phase:\n", phaseName)

	// Count statuses
	statusCounts := make(map[string]int)
	for _, task := range tasks {
		statusCounts[task.Status]++

		// Display task line
		iterationInfo := ""
		if task.Iteration > 1 {
			iterationInfo = fmt.Sprintf(" - iteration %d", task.Iteration)
		}
		fmt.Printf("  [%s] %s (%s)%s\n", task.Id, task.Name, task.Status, iterationInfo)
	}

	// Summary line
	fmt.Printf("\n%d total tasks", len(tasks))
	for status, count := range statusCounts {
		fmt.Printf(": %d %s", count, status)
	}
	fmt.Println()

	return nil
}

// displayTaskDetail shows detailed information about a specific task.
func displayTaskDetail(task project.TaskState) error {
	fmt.Printf("Task: %s - %s\n", task.Id, task.Name)
	fmt.Printf("Phase: %s\n", task.Phase)
	fmt.Printf("Status: %s\n", task.Status)
	fmt.Printf("Iteration: %d\n", task.Iteration)
	fmt.Printf("Assigned Agent: %s\n", task.Assigned_agent)
	fmt.Println()

	// Timestamps
	fmt.Println("Timestamps:")
	fmt.Printf("  Created:   %s\n", task.Created_at.Format("2006-01-02 15:04:05"))
	if !task.Started_at.IsZero() {
		fmt.Printf("  Started:   %s\n", task.Started_at.Format("2006-01-02 15:04:05"))
	}
	fmt.Printf("  Updated:   %s\n", task.Updated_at.Format("2006-01-02 15:04:05"))
	if !task.Completed_at.IsZero() {
		fmt.Printf("  Completed: %s\n", task.Completed_at.Format("2006-01-02 15:04:05"))
	}
	fmt.Println()

	// Inputs
	if len(task.Inputs) > 0 {
		fmt.Printf("Inputs (%d):\n", len(task.Inputs))
		for i, input := range task.Inputs {
			fmt.Printf("  [%d] %s: %s\n", i, input.Type, input.Path)
			// Show metadata if present
			if len(input.Metadata) > 0 {
				for key, value := range input.Metadata {
					fmt.Printf("      └─ metadata.%s: %v\n", key, value)
				}
			}
		}
		fmt.Println()
	}

	// Outputs
	if len(task.Outputs) > 0 {
		fmt.Printf("Outputs (%d):\n", len(task.Outputs))
		for i, output := range task.Outputs {
			fmt.Printf("  [%d] %s: %s\n", i, output.Type, output.Path)
			// Show metadata if present
			if len(output.Metadata) > 0 {
				for key, value := range output.Metadata {
					fmt.Printf("      └─ metadata.%s: %v\n", key, value)
				}
			}
		}
		fmt.Println()
	}

	// File locations
	taskDir := filepath.Join(".sow/project/phases", task.Phase, "tasks", task.Id)
	fmt.Println("Files:")
	fmt.Printf("  Description: %s/description.md\n", taskDir)
	fmt.Printf("  Log:         %s/log.md\n", taskDir)
	fmt.Printf("  Feedback:    %s/feedback/\n", taskDir)
	fmt.Println()

	// Metadata
	if len(task.Metadata) > 0 {
		fmt.Println("Metadata:")
		for key, value := range task.Metadata {
			fmt.Printf("  %s: %v\n", key, value)
		}
	}

	return nil
}

// generateNextTaskID calculates the next gap-numbered task ID.
// Returns "010" for the first task, then "020", "030", etc.
func generateNextTaskID(tasks []project.TaskState) string {
	if len(tasks) == 0 {
		return "010"
	}

	// Find highest ID
	maxID := 0
	for _, task := range tasks {
		id, err := strconv.Atoi(task.Id)
		if err == nil && id > maxID {
			maxID = id
		}
	}

	// Return next gap-numbered ID
	nextID := maxID + 10
	return fmt.Sprintf("%03d", nextID)
}

// createTaskDirectory creates the task directory structure.
func createTaskDirectory(ctx *sow.Context, phaseName, taskID, description string) error {
	taskDir := filepath.Join(ctx.RepoRoot(), ".sow/project/phases", phaseName, "tasks", taskID)

	// Create directories
	if err := os.MkdirAll(filepath.Join(taskDir, "feedback"), 0755); err != nil {
		return err
	}

	// Create description.md
	descPath := filepath.Join(taskDir, "description.md")
	descContent := description
	if descContent == "" {
		descContent = "# Task Description\n\nTODO: Add task description\n"
	} else {
		descContent = descContent + "\n"
	}
	if err := os.WriteFile(descPath, []byte(descContent), 0644); err != nil {
		return err
	}

	// Create empty log.md
	logPath := filepath.Join(taskDir, "log.md")
	logContent := "# Task Log\n\nWorker actions will be logged here.\n"
	if err := os.WriteFile(logPath, []byte(logContent), 0644); err != nil {
		return err
	}

	return nil
}
