// Code generated by "cue exp gengotypes"; DO NOT EDIT.

package project

import (
	"time"
)

// ArtifactState represents a file or document produced or consumed by a phase or task.
// Artifacts track important work products such as design documents, task lists,
// review reports, and other phase outputs. Each artifact has a type, path, approval
// status, and optional metadata.
type ArtifactState struct {
	// type identifies the kind of artifact.
	// Must be non-empty. Examples: "task_list", "review", "design_doc", "adr"
	// The type determines how the artifact is interpreted and used.
	Type string `json:"type"`

	// path is the relative path to the artifact file from .sow/project/.
	// Must be non-empty. Example: "phases/planning/task-breakdown.md"
	Path string `json:"path"`

	// approved indicates whether this artifact has been reviewed and approved.
	// Used by state machines to gate transitions (e.g., can't proceed until artifact approved).
	Approved bool `json:"approved"`

	// created_at is the timestamp when this artifact was created or added.
	Created_at time.Time `json:"created_at"`

	// metadata holds artifact-type-specific data.
	// Structure and validation are defined by the artifact type.
	// Example uses: review assessment (pass/fail), document category, custom properties.
	Metadata map[string]any/* CUE top */ `json:"metadata,omitempty"`
}

// PhaseState represents the state of a single phase within a project.
// Phases are major divisions of work (e.g., planning, implementation, review).
// Each phase has status tracking, timestamps, optional metadata, and collections
// of artifacts and tasks.
type PhaseState struct {
	// status indicates the current status of the phase.
	// Must be non-empty. Common values: "pending", "in_progress", "completed", "failed"
	// Actual valid statuses are defined by the project type.
	Status string `json:"status"`

	// enabled indicates whether this phase is enabled for the current project.
	// Some project types may have optional phases that can be skipped.
	Enabled bool `json:"enabled"`

	// created_at is the timestamp when this phase was created.
	Created_at time.Time `json:"created_at"`

	// started_at is the optional timestamp when work on this phase began.
	// Only set when the phase transitions to an active state.
	Started_at time.Time `json:"started_at,omitempty"`

	// completed_at is the optional timestamp when this phase finished.
	// Only set when the phase transitions to a completed state.
	Completed_at time.Time `json:"completed_at,omitempty"`

	// failed_at is the optional timestamp when this phase failed.
	// Only set when the phase transitions to a failed state.
	Failed_at time.Time `json:"failed_at,omitempty"`

	// iteration tracks how many times this phase has been entered.
	// Starts at 1, increments on re-entry after failure.
	// Example: implementation iteration 2 = rework after review failure
	Iteration int64 `json:"iteration,omitempty"`

	// metadata holds project-type-specific data for this phase.
	// Structure and validation are defined by the project type.
	// Example uses: complexity rating, approval flags, custom settings.
	Metadata map[string]any/* CUE top */ `json:"metadata,omitempty"`

	// inputs is the list of artifacts that this phase consumes.
	// These artifacts are typically outputs from previous phases.
	Inputs []ArtifactState `json:"inputs"`

	// outputs is the list of artifacts that this phase produces.
	// These become available for use by subsequent phases.
	Outputs []ArtifactState `json:"outputs"`

	// tasks is the list of tasks belonging to this phase.
	// Each task represents a discrete unit of work to be completed.
	Tasks []TaskState `json:"tasks"`
}

// TaskState represents a discrete unit of work within a phase.
// Tasks are the atomic units of project execution, each with a unique ID,
// status tracking, iteration support for refinement cycles, and collections
// of input and output artifacts.
type TaskState struct {
	// id is the unique three-digit identifier for this task.
	// Must match pattern: exactly 3 digits (e.g., "001", "010", "042", "999")
	// IDs are typically gap-numbered (010, 020, 030) to allow insertion.
	Id string `json:"id"`

	// name is the human-readable name of the task.
	// Must be non-empty. Example: "Implement JWT middleware", "Write unit tests"
	Name string `json:"name"`

	// phase identifies which phase this task belongs to.
	// Must be non-empty. Example: "implementation", "testing", "documentation"
	Phase string `json:"phase"`

	// status indicates the current state of the task.
	// Must be one of: "pending" (not started), "in_progress" (actively working),
	// "completed" (successfully finished), "abandoned" (cancelled/obsolete).
	Status string `json:"status"`

	// created_at is the timestamp when this task was created.
	Created_at time.Time `json:"created_at"`

	// started_at is the optional timestamp when work on this task began.
	// Only set when the task transitions to "in_progress" status.
	Started_at time.Time `json:"started_at,omitempty"`

	// updated_at is the timestamp of the last modification to this task.
	// Updated whenever task state changes (status, iteration, artifacts, etc.).
	Updated_at time.Time `json:"updated_at"`

	// completed_at is the optional timestamp when this task finished.
	// Only set when the task transitions to "completed" or "abandoned" status.
	Completed_at time.Time `json:"completed_at,omitempty"`

	// iteration is the current iteration number for this task.
	// Must be >= 1. Starts at 1, increments when task is sent back for revisions.
	// Supports refinement cycles (e.g., review → revise → review again).
	Iteration int64 `json:"iteration"`

	// assigned_agent identifies the type of agent responsible for this task.
	// Must be non-empty. Examples: "implementer", "architect", "reviewer"
	// Determines which agent type is spawned to execute the task.
	Assigned_agent string `json:"assigned_agent"`

	// inputs is the list of artifacts that this task consumes.
	// These provide context and requirements for completing the task.
	// Examples: design documents, specifications, feedback files.
	Inputs []ArtifactState `json:"inputs"`

	// outputs is the list of artifacts that this task produces.
	// These represent the work product of completing the task.
	// Examples: code files, test files, documentation.
	Outputs []ArtifactState `json:"outputs"`

	// metadata holds task-specific data.
	// Structure and validation are defined by the project type.
	// Example uses: complexity rating, dependencies, custom properties.
	Metadata map[string]any/* CUE top */ `json:"metadata,omitempty"`
}

// ProjectState represents the complete state of a project in the sow system.
// It includes project identification, timestamps, all phases, and state machine position.
// This is the root type for all project state files stored at .sow/project/state.yaml.
type ProjectState struct {
	// name is the unique identifier for the project.
	// Must be lowercase alphanumeric with hyphens allowed (not at start/end).
	// Example: "my-project", "auth-implementation", "bug-fix-123"
	Name string `json:"name"`

	// type identifies the project type (e.g., "standard", "exploration", "design").
	// Must be lowercase alphanumeric with underscores allowed.
	// Each type defines its own phase lifecycle and behavior.
	Type string `json:"type"`

	// branch is the git branch associated with this project.
	// Must be non-empty. Example: "feat/add-authentication"
	Branch string `json:"branch"`

	// description is an optional human-readable description of the project.
	Description string `json:"description,omitempty"`

	// created_at is the timestamp when the project was initialized.
	Created_at time.Time `json:"created_at"`

	// updated_at is the timestamp of the last project state modification.
	Updated_at time.Time `json:"updated_at"`

	// phases is a map of phase names to phase state.
	// Keys are phase identifiers (e.g., "planning", "implementation", "review").
	// Values contain the state and collections for each phase.
	Phases map[string]PhaseState `json:"phases"`

	// statechart tracks the current position in the project state machine.
	// This determines which operations are valid at any given time.
	Statechart StatechartState `json:"statechart"`
}

// StatechartState represents the current position in a project's state machine.
// It tracks which state the project is in and when it last transitioned.
type StatechartState struct {
	// current_state is the name of the current state in the state machine.
	// Must be non-empty. Example: "PlanningActive", "ImplementationExecuting"
	Current_state string `json:"current_state"`

	// updated_at is the timestamp of the last state transition.
	Updated_at time.Time `json:"updated_at"`
}
