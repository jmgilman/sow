// Code generated by "cue exp gengotypes"; DO NOT EDIT.

package schemas

import (
	"time"
)

// Config defines the schema for the sow configuration file at:
// .sow/config.yaml
//
// This allows teams to customize where formal artifacts are stored.
type Config struct {
	// Artifact storage locations
	// All paths are relative to repository root
	Artifacts *struct {
		// Where to store Architecture Decision Records
		// Default: ".sow/knowledge/adrs"
		Adrs *string `json:"adrs,omitempty"`

		// Where to store design documents
		// Default: ".sow/knowledge/design"
		Design_docs *string `json:"design_docs,omitempty"`
	} `json:"artifacts,omitempty"`
}

// KnowledgeIndex defines the schema for the knowledge index at:
// .sow/knowledge/index.yaml
//
// This tracks permanent artifacts and their metadata.
type KnowledgeIndex struct {
	// Exploration summaries
	Explorations []ExplorationSummary `json:"explorations"`

	// ADR references (if stored in .sow/knowledge/adrs/)
	Adrs []ArtifactReference `json:"adrs,omitempty"`

	// Design document references (if stored in .sow/knowledge/design/)
	Design_docs []ArtifactReference `json:"design_docs,omitempty"`
}

// ExplorationSummary represents a completed exploration
type ExplorationSummary struct {
	// Exploration topic
	Topic string `json:"topic"`

	// Path to summary document (relative to .sow/knowledge/explorations/)
	Summary_path string `json:"summary_path"`

	// Original exploration branch
	Branch string `json:"branch"`

	// When exploration was completed
	Completed_at time.Time `json:"completed_at"`

	// Tags for discoverability
	Tags []string `json:"tags"`
}

// ArtifactReference represents a reference to a permanent artifact
type ArtifactReference struct {
	// Path to artifact (relative to .sow/knowledge/)
	Path string `json:"path"`

	// Brief description
	Description string `json:"description"`

	// When artifact was created
	Created_at time.Time `json:"created_at"`

	// Tags for discoverability
	Tags []string `json:"tags"`
}

// RefManifest defines the schema for .sow-ref.yaml manifest files.
//
// These manifests are required in all OCI-distributed refs and define
// metadata including title, link name, content description, classifications,
// tags, and optional provenance/packaging/hints sections.
type RefManifest struct {
	// schema_version is the semantic version of this manifest format.
	// Format: MAJOR.MINOR.PATCH
	Schema_version string `json:"schema_version"`

	// ref contains core identification for this reference.
	Ref RefIdentification `json:"ref"`

	// content describes what this reference contains.
	Content RefContent `json:"content"`

	// provenance contains optional authorship and source information.
	Provenance RefProvenance `json:"provenance,omitempty"`

	// packaging contains optional publishing configuration.
	Packaging RefPackaging `json:"packaging,omitempty"`

	// hints provides optional LLM usage suggestions.
	Hints RefHints `json:"hints,omitempty"`

	// metadata is a freeform map for organization-specific data.
	Metadata map[string]any/* CUE top */ `json:"metadata,omitempty"`
}

// RefIdentification contains core identification fields for a reference.
type RefIdentification struct {
	// title is the human-readable name for this reference.
	Title string `json:"title"`

	// link is the symlink name in kebab-case format.
	// Must start and end with alphanumeric, can contain hyphens in the middle.
	// Examples: "go-standards", "api-patterns", "my-ref"
	Link string `json:"link"`
}

// RefContent describes the content of a reference.
type RefContent struct {
	// description is a non-empty string describing the reference.
	Description string `json:"description"`

	// summary is an optional longer description.
	Summary string `json:"summary,omitempty"`

	// classifications is an array of at least one classification.
	Classifications []RefClassification `json:"classifications"`

	// tags is an array of at least one tag.
	Tags []string `json:"tags"`
}

// RefClassification categorizes a reference by type.
type RefClassification struct {
	// type is one of the predefined classification types.
	Type ClassificationType `json:"type"`

	// description is an optional string describing the classification.
	Description string `json:"description,omitempty"`
}

// ClassificationType defines the allowed classification values.
type ClassificationType string

// RefProvenance contains optional authorship and source information.
type RefProvenance struct {
	// authors is an optional array of author names.
	Authors []string `json:"authors,omitempty"`

	// created is an optional RFC 3339 timestamp string.
	Created string `json:"created,omitempty"`

	// updated is an optional RFC 3339 timestamp string.
	Updated string `json:"updated,omitempty"`

	// source is an optional source URL (e.g., git URL).
	Source string `json:"source,omitempty"`

	// license is an optional license identifier (e.g., "MIT", "Apache-2.0").
	License string `json:"license,omitempty"`
}

// RefPackaging contains optional publishing configuration.
type RefPackaging struct {
	// exclude is an optional array of glob patterns to exclude when packaging.
	Exclude []string `json:"exclude,omitempty"`
}

// RefHints provides optional LLM usage suggestions.
type RefHints struct {
	// suggested_queries is an optional array of example queries.
	Suggested_queries []string `json:"suggested_queries,omitempty"`

	// primary_files is an optional array of important file paths.
	Primary_files []string `json:"primary_files,omitempty"`
}

// RefsCacheIndex defines the schema for ~/.cache/sow/index.json
//
// This is the cache index containing transient metadata about cached
// references. Stored per-machine, not committed to git.
type RefsCacheIndex struct {
	// Schema version (semantic versioning)
	Version string `json:"version"`

	// Cached reference metadata
	Refs []CachedRef `json:"refs"`
}

// CachedRef represents a cached reference
type CachedRef struct {
	// Reference ID (matches ID from committed or local index)
	Id string `json:"id"`

	// Type inferred from source URL (stored for quick lookup)
	Type string `json:"type"`

	// Absolute cache path (e.g., /Users/josh/.cache/sow/refs/git/abc123/)
	Cache_path string `json:"cache_path"`

	// Last updated timestamp
	Last_updated time.Time `json:"last_updated"`

	// Repositories using this cached ref
	Used_by []CacheUsage `json:"used_by"`

	// Type-specific metadata
	Metadata CacheMetadata `json:"metadata"`
}

// CacheUsage represents a repository using this cached ref
type CacheUsage struct {
	// Absolute path to consuming repository
	Repo_path string `json:"repo_path"`

	// How the cache is linked (symlink on Unix, copy on Windows)
	Link_type string `json:"link_type"`

	// Link name in the consuming repo's .sow/refs/ directory
	Link_name string `json:"link_name"`
}

// CacheMetadata is polymorphic based on type
type CacheMetadata struct {
	// Git type metadata
	Git GitMetadata `json:"git,omitempty"`

	// File type metadata
	File FileMetadata `json:"file,omitempty"`
}

// GitMetadata contains git-specific cache data
type GitMetadata struct {
	// Current local commit SHA
	Commit_sha string `json:"commit_sha"`

	// Latest remote commit SHA (updated on status check)
	Remote_sha string `json:"remote_sha,omitempty"`

	// Last time remote was checked
	Last_checked time.Time `json:"last_checked,omitempty"`

	// Staleness status
	Status string `json:"status"`

	// Number of commits behind remote (0 if current)
	Commits_behind int64 `json:"commits_behind"`
}

// FileMetadata contains file-specific cache data
type FileMetadata struct {
}

// RefsCommittedIndex defines the schema for .sow/refs/index.json
//
// This is the committed index containing categorical metadata about
// refs, shared with the team via git. Contains configuration
// but not transient data like SHAs or timestamps.
type RefsCommittedIndex struct {
	// Schema version (semantic versioning)
	Version string `json:"version"`

	// Reference definitions
	Refs []Ref `json:"refs"`
}

// Ref represents a reference to external content
type Ref struct {
	// Unique identifier (auto-generated)
	Id string `json:"id"`

	// Source URL with scheme that determines type
	// Examples:
	//   - git+https://github.com/org/repo
	//   - git+ssh://git@github.com/org/repo
	//   - git@github.com:org/repo (auto-converted to git+ssh://)
	//   - file:///absolute/path
	Source string `json:"source"`

	// Semantic type (what the content represents)
	Semantic string `json:"semantic"`

	// Symlink name in .sow/refs/
	Link string `json:"link"`

	// Topic keywords for categorization
	Tags []string `json:"tags"`

	// One-sentence description
	Description string `json:"description"`

	// 2-3 sentence summary (optional)
	Summary string `json:"summary"`

	// Type-specific configuration
	// Structure depends on URL scheme
	Config RefConfig `json:"config"`
}

// RefConfig is a polymorphic config structure
// Validation depends on the source URL scheme
type RefConfig struct {
	// Git type config (for git+https://, git+ssh://, git@ URLs)
	// Branch name (optional, defaults to repo default)
	Branch string `json:"branch,omitempty"`

	// Subpath within repository (optional, defaults to root)
	// Use "" or omit for root
	//
	// Future type configs would be added here
	// For example, web type:
	// scrape_depth?: int & >=1
	// follow_links?: bool
	Path string `json:"path,omitempty"`
}

// RefsLocalIndex defines the schema for .sow/refs/index.local.json
//
// This is the local-only index for references that should not be
// shared with the team (e.g., work-in-progress docs, personal notes).
// This file is git-ignored.
//
// Note: File refs are typically added as local refs since they
// reference paths on the local machine.
type RefsLocalIndex struct {
	// Schema version (semantic versioning)
	Version string `json:"version"`

	// Local reference definitions
	// Uses same structure as committed refs
	Refs []Ref `json:"refs"`
}

// UserConfig defines the schema for the user configuration file at:
// ~/.config/sow/config.yaml
//
// This allows users to configure which AI CLI executors handle which agent roles.
type UserConfig struct {
	// Agent configuration
	Agents *struct {
		// Executor definitions
		// Keys are executor names (e.g., "claude-code", "cursor")
		Executors map[string]struct {
			// Type of executor
			Type string `json:"type"`

			// Executor settings
			Settings *struct {
				// Skip permission prompts
				Yolo_mode *bool `json:"yolo_mode,omitempty"`

				// AI model to use (only meaningful for claude type)
				Model *string `json:"model,omitempty"`
			} `json:"settings,omitempty"`

			// Additional CLI arguments
			Custom_args []string `json:"custom_args,omitempty"`
		} `json:"executors,omitempty"`

		// Bindings from agent roles to executor names
		Bindings *struct {
			Orchestrator *string `json:"orchestrator,omitempty"`

			Implementer *string `json:"implementer,omitempty"`

			Architect *string `json:"architect,omitempty"`

			Reviewer *string `json:"reviewer,omitempty"`

			Planner *string `json:"planner,omitempty"`

			Researcher *string `json:"researcher,omitempty"`

			Decomposer *string `json:"decomposer,omitempty"`
		} `json:"bindings,omitempty"`
	} `json:"agents,omitempty"`
}
