// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"github.com/jmgilman/sow/libs/exec"
	"sync"
)

// Ensure, that ExecutorMock does implement exec.Executor.
// If this is not the case, regenerate this file with moq.
var _ exec.Executor = &ExecutorMock{}

// ExecutorMock is a mock implementation of exec.Executor.
//
//	func TestSomethingThatUsesExecutor(t *testing.T) {
//
//		// make and configure a mocked exec.Executor
//		mockedExecutor := &ExecutorMock{
//			CommandFunc: func() string {
//				panic("mock out the Command method")
//			},
//			ExistsFunc: func() bool {
//				panic("mock out the Exists method")
//			},
//			RunFunc: func(args ...string) (string, string, error) {
//				panic("mock out the Run method")
//			},
//			RunContextFunc: func(ctx context.Context, args ...string) (string, string, error) {
//				panic("mock out the RunContext method")
//			},
//			RunSilentFunc: func(args ...string) error {
//				panic("mock out the RunSilent method")
//			},
//			RunSilentContextFunc: func(ctx context.Context, args ...string) error {
//				panic("mock out the RunSilentContext method")
//			},
//		}
//
//		// use mockedExecutor in code that requires exec.Executor
//		// and then make assertions.
//
//	}
type ExecutorMock struct {
	// CommandFunc mocks the Command method.
	CommandFunc func() string

	// ExistsFunc mocks the Exists method.
	ExistsFunc func() bool

	// RunFunc mocks the Run method.
	RunFunc func(args ...string) (string, string, error)

	// RunContextFunc mocks the RunContext method.
	RunContextFunc func(ctx context.Context, args ...string) (string, string, error)

	// RunSilentFunc mocks the RunSilent method.
	RunSilentFunc func(args ...string) error

	// RunSilentContextFunc mocks the RunSilentContext method.
	RunSilentContextFunc func(ctx context.Context, args ...string) error

	// calls tracks calls to the methods.
	calls struct {
		// Command holds details about calls to the Command method.
		Command []struct {
		}
		// Exists holds details about calls to the Exists method.
		Exists []struct {
		}
		// Run holds details about calls to the Run method.
		Run []struct {
			// Args is the args argument value.
			Args []string
		}
		// RunContext holds details about calls to the RunContext method.
		RunContext []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Args is the args argument value.
			Args []string
		}
		// RunSilent holds details about calls to the RunSilent method.
		RunSilent []struct {
			// Args is the args argument value.
			Args []string
		}
		// RunSilentContext holds details about calls to the RunSilentContext method.
		RunSilentContext []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Args is the args argument value.
			Args []string
		}
	}
	lockCommand          sync.RWMutex
	lockExists           sync.RWMutex
	lockRun              sync.RWMutex
	lockRunContext       sync.RWMutex
	lockRunSilent        sync.RWMutex
	lockRunSilentContext sync.RWMutex
}

// Command calls CommandFunc.
func (mock *ExecutorMock) Command() string {
	if mock.CommandFunc == nil {
		panic("ExecutorMock.CommandFunc: method is nil but Executor.Command was just called")
	}
	callInfo := struct {
	}{}
	mock.lockCommand.Lock()
	mock.calls.Command = append(mock.calls.Command, callInfo)
	mock.lockCommand.Unlock()
	return mock.CommandFunc()
}

// CommandCalls gets all the calls that were made to Command.
// Check the length with:
//
//	len(mockedExecutor.CommandCalls())
func (mock *ExecutorMock) CommandCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockCommand.RLock()
	calls = mock.calls.Command
	mock.lockCommand.RUnlock()
	return calls
}

// Exists calls ExistsFunc.
func (mock *ExecutorMock) Exists() bool {
	if mock.ExistsFunc == nil {
		panic("ExecutorMock.ExistsFunc: method is nil but Executor.Exists was just called")
	}
	callInfo := struct {
	}{}
	mock.lockExists.Lock()
	mock.calls.Exists = append(mock.calls.Exists, callInfo)
	mock.lockExists.Unlock()
	return mock.ExistsFunc()
}

// ExistsCalls gets all the calls that were made to Exists.
// Check the length with:
//
//	len(mockedExecutor.ExistsCalls())
func (mock *ExecutorMock) ExistsCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockExists.RLock()
	calls = mock.calls.Exists
	mock.lockExists.RUnlock()
	return calls
}

// Run calls RunFunc.
func (mock *ExecutorMock) Run(args ...string) (string, string, error) {
	if mock.RunFunc == nil {
		panic("ExecutorMock.RunFunc: method is nil but Executor.Run was just called")
	}
	callInfo := struct {
		Args []string
	}{
		Args: args,
	}
	mock.lockRun.Lock()
	mock.calls.Run = append(mock.calls.Run, callInfo)
	mock.lockRun.Unlock()
	return mock.RunFunc(args...)
}

// RunCalls gets all the calls that were made to Run.
// Check the length with:
//
//	len(mockedExecutor.RunCalls())
func (mock *ExecutorMock) RunCalls() []struct {
	Args []string
} {
	var calls []struct {
		Args []string
	}
	mock.lockRun.RLock()
	calls = mock.calls.Run
	mock.lockRun.RUnlock()
	return calls
}

// RunContext calls RunContextFunc.
func (mock *ExecutorMock) RunContext(ctx context.Context, args ...string) (string, string, error) {
	if mock.RunContextFunc == nil {
		panic("ExecutorMock.RunContextFunc: method is nil but Executor.RunContext was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Args []string
	}{
		Ctx:  ctx,
		Args: args,
	}
	mock.lockRunContext.Lock()
	mock.calls.RunContext = append(mock.calls.RunContext, callInfo)
	mock.lockRunContext.Unlock()
	return mock.RunContextFunc(ctx, args...)
}

// RunContextCalls gets all the calls that were made to RunContext.
// Check the length with:
//
//	len(mockedExecutor.RunContextCalls())
func (mock *ExecutorMock) RunContextCalls() []struct {
	Ctx  context.Context
	Args []string
} {
	var calls []struct {
		Ctx  context.Context
		Args []string
	}
	mock.lockRunContext.RLock()
	calls = mock.calls.RunContext
	mock.lockRunContext.RUnlock()
	return calls
}

// RunSilent calls RunSilentFunc.
func (mock *ExecutorMock) RunSilent(args ...string) error {
	if mock.RunSilentFunc == nil {
		panic("ExecutorMock.RunSilentFunc: method is nil but Executor.RunSilent was just called")
	}
	callInfo := struct {
		Args []string
	}{
		Args: args,
	}
	mock.lockRunSilent.Lock()
	mock.calls.RunSilent = append(mock.calls.RunSilent, callInfo)
	mock.lockRunSilent.Unlock()
	return mock.RunSilentFunc(args...)
}

// RunSilentCalls gets all the calls that were made to RunSilent.
// Check the length with:
//
//	len(mockedExecutor.RunSilentCalls())
func (mock *ExecutorMock) RunSilentCalls() []struct {
	Args []string
} {
	var calls []struct {
		Args []string
	}
	mock.lockRunSilent.RLock()
	calls = mock.calls.RunSilent
	mock.lockRunSilent.RUnlock()
	return calls
}

// RunSilentContext calls RunSilentContextFunc.
func (mock *ExecutorMock) RunSilentContext(ctx context.Context, args ...string) error {
	if mock.RunSilentContextFunc == nil {
		panic("ExecutorMock.RunSilentContextFunc: method is nil but Executor.RunSilentContext was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Args []string
	}{
		Ctx:  ctx,
		Args: args,
	}
	mock.lockRunSilentContext.Lock()
	mock.calls.RunSilentContext = append(mock.calls.RunSilentContext, callInfo)
	mock.lockRunSilentContext.Unlock()
	return mock.RunSilentContextFunc(ctx, args...)
}

// RunSilentContextCalls gets all the calls that were made to RunSilentContext.
// Check the length with:
//
//	len(mockedExecutor.RunSilentContextCalls())
func (mock *ExecutorMock) RunSilentContextCalls() []struct {
	Ctx  context.Context
	Args []string
} {
	var calls []struct {
		Ctx  context.Context
		Args []string
	}
	mock.lockRunSilentContext.RLock()
	calls = mock.calls.RunSilentContext
	mock.lockRunSilentContext.RUnlock()
	return calls
}
