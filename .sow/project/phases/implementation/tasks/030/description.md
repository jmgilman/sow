# Generate Mock via moq in mocks Subpackage

## Context

This task is part of creating the `libs/exec` module. Tasks 010 and 020 created the module structure, interface, and LocalExecutor implementation. This task generates a mock for the `Executor` interface using `moq` and places it in a dedicated `mocks` subpackage.

The old code had a hand-written `MockExecutor` in `cli/internal/exec/mock.go`. Per TESTING.md standards, all public interfaces must have mocks generated via `moq`. This provides consistent, maintainable mocks that are automatically kept in sync with the interface.

## Requirements

### 1. Create mocks Subpackage Structure

Create the mocks subpackage:
```
libs/exec/
├── executor.go          # Interface (from task 010)
├── local.go             # Implementation (from task 020)
├── local_test.go        # Tests (from task 020)
└── mocks/
    └── executor.go      # Generated mock via moq
```

### 2. Add go:generate Directive

Add a `//go:generate` comment to `executor.go` (or `doc.go`) to generate the mock:

```go
//go:generate go run github.com/matryer/moq@latest -out mocks/executor.go -pkg mocks . Executor
```

**Key options:**
- `-out mocks/executor.go` - Output file location
- `-pkg mocks` - Package name for generated file
- `. Executor` - Generate mock for Executor interface in current package

### 3. Run go generate

Execute `go generate ./...` in `libs/exec/` to generate the mock file.

### 4. Verify Generated Mock

The generated mock should:
- Be in package `mocks`
- Implement `exec.Executor` interface
- Provide function fields for each method (e.g., `CommandFunc`, `RunFunc`)
- Track calls for inspection if needed
- Be importable as `github.com/jmgilman/sow/libs/exec/mocks`

### 5. Update Module Dependencies

The `go generate` command will require adding the moq tool as a tool dependency. Add it to `go.mod` via:
```bash
go get github.com/matryer/moq@latest
```

Or let `go generate` handle it automatically with `go run`.

## Acceptance Criteria

1. [ ] `libs/exec/mocks/` directory exists
2. [ ] `libs/exec/mocks/executor.go` is generated by moq
3. [ ] `//go:generate` directive is present in executor.go or doc.go
4. [ ] Generated mock implements `exec.Executor` interface
5. [ ] Mock is in package `mocks` (not `exec`)
6. [ ] `go generate ./...` completes without errors
7. [ ] `go build ./...` succeeds including mocks package
8. [ ] Linting passes for generated file (may need to exclude from some linters)

**Verification tests:**
- Mock compiles and implements Executor
- Mock can be used in a simple test scenario (add a quick smoke test if desired)

## Technical Details

### go:generate Directive Location

Add to `libs/exec/executor.go` near the top:

```go
package exec

//go:generate go run github.com/matryer/moq@latest -out mocks/executor.go -pkg mocks . Executor

import "context"

// Executor defines the interface for executing shell commands.
type Executor interface {
    // ...
}
```

### Generated Mock Structure

moq generates mocks with this pattern:

```go
// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
    "context"
    "sync"

    "github.com/jmgilman/sow/libs/exec"
)

// ExecutorMock is a mock implementation of exec.Executor.
type ExecutorMock struct {
    // CommandFunc mocks the Command method.
    CommandFunc func() string

    // ExistsFunc mocks the Exists method.
    ExistsFunc func() bool

    // RunFunc mocks the Run method.
    RunFunc func(args ...string) (string, string, error)

    // RunContextFunc mocks the RunContext method.
    RunContextFunc func(ctx context.Context, args ...string) (string, string, error)

    // RunSilentFunc mocks the RunSilent method.
    RunSilentFunc func(args ...string) error

    // RunSilentContextFunc mocks the RunSilentContext method.
    RunSilentContextFunc func(ctx context.Context, args ...string) error

    // calls tracks calls to the methods.
    calls struct {
        // ...
    }
    // ...
}
```

### Usage Example

```go
import (
    "github.com/jmgilman/sow/libs/exec/mocks"
)

func TestSomething(t *testing.T) {
    mock := &mocks.ExecutorMock{
        CommandFunc: func() string { return "gh" },
        ExistsFunc: func() bool { return true },
        RunFunc: func(args ...string) (string, string, error) {
            return `{"number": 123}`, "", nil
        },
    }

    // Use mock in tests...
}
```

### Linter Configuration

The generated mock may trigger some linters. If needed, add exclusions to `.golangci.yml` for the mocks directory, but first check if the generated code passes - moq typically generates lint-compliant code.

## Relevant Inputs

- `libs/exec/executor.go` - Interface to mock (from task 010)
- `.standards/TESTING.md` - Testing standards requiring moq for mocks
- `cli/internal/exec/mock.go` - Old hand-written mock (for reference, will be replaced)
- `.sow/project/context/issue-115.md` - Full issue requirements

## Examples

### Complete executor.go with generate directive

```go
package exec

//go:generate go run github.com/matryer/moq@latest -out mocks/executor.go -pkg mocks . Executor

import "context"

// Executor defines the interface for executing shell commands.
//
// This interface allows for easy mocking in tests while providing a consistent
// API for command execution across the codebase.
type Executor interface {
    // Command returns the command name this executor wraps.
    Command() string

    // Exists checks if the command exists in PATH.
    Exists() bool

    // Run executes the command with the given arguments.
    // Returns stdout, stderr, and error.
    Run(args ...string) (stdout, stderr string, err error)

    // RunContext executes the command with the given arguments and context.
    RunContext(ctx context.Context, args ...string) (stdout, stderr string, err error)

    // RunSilent executes the command but only returns an error.
    RunSilent(args ...string) error

    // RunSilentContext is like RunSilent but accepts a context.
    RunSilentContext(ctx context.Context, args ...string) error
}
```

### Quick smoke test (optional, can add to local_test.go or separate file)

```go
func TestMockImplementsExecutor(t *testing.T) {
    // This is a compile-time check - if it compiles, the mock is valid
    var _ exec.Executor = &mocks.ExecutorMock{}
}

func TestMockBasicUsage(t *testing.T) {
    mock := &mocks.ExecutorMock{
        RunFunc: func(args ...string) (string, string, error) {
            return "output", "", nil
        },
    }

    stdout, stderr, err := mock.Run("arg1")

    assert.NoError(t, err)
    assert.Equal(t, "output", stdout)
    assert.Empty(t, stderr)
}
```

## Dependencies

- Task 010 must be completed (interface definition)
- Task 020 should be completed (implementation), though not strictly required

## Constraints

- **Use moq, not hand-written mocks** - Per TESTING.md standards
- **Use `go run` to avoid requiring moq installation** - `go run github.com/matryer/moq@latest`
- **Pin moq to a recent version** - Using `@latest` is acceptable, but pinning to a specific version is more reproducible
- **Do not remove old mock.go yet** - The old `cli/internal/exec/mock.go` stays until task 050
- **Generated files should not be manually edited** - They will be regenerated
- Must pass `golangci-lint run` (may need exclusions for generated files)
