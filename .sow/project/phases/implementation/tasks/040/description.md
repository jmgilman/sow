# Task 040: Error Handling and Validation

## Context

This task implements comprehensive error handling and validation for the AddBranch API. While Task 030 includes basic validation (panic for missing discriminator/branches), this task ensures robust error handling for edge cases and provides helpful error messages for users.

This is the fourth task in a 5-phase TDD implementation of the AddBranch API. It builds on the working implementation from Task 030 to add defensive programming and user-friendly error messages.

### Project Goal

Ensure the AddBranch API is robust and user-friendly by:
- Detecting configuration errors early (at build time)
- Providing helpful runtime error messages when discriminators return unexpected values
- Handling edge cases gracefully
- Making debugging easier through clear error messages

### Why This Task Fourth

Now that the happy path works (Task 030), we can focus on edge cases and error conditions. This follows the TDD principle of getting the basic functionality working before adding robustness.

## Requirements

### 1. Enhanced Discriminator Error Messages

**File**: `/Users/josh/code/sow/.sow/worktrees/77-sdk-branching-support-addbranch-api/cli/internal/sdks/project/builder.go`

The OnAdvance determiner generated by AddBranch already includes basic error handling. Ensure it provides helpful messages:

```go
// In AddBranch, the generated OnAdvance determiner should include:
b.OnAdvance(from, func(p *state.Project) (sdkstate.Event, error) {
    value := bc.discriminator(p)

    path, exists := bc.branches[value]
    if !exists {
        // Build helpful error message with available values
        availableValues := make([]string, 0, len(bc.branches))
        for v := range bc.branches {
            availableValues = append(availableValues, fmt.Sprintf("%q", v))
        }

        // Sort for deterministic output
        sort.Strings(availableValues)

        return "", fmt.Errorf(
            "no branch defined for discriminator value %q from state %s (available values: %s)",
            value, from, strings.Join(availableValues, ", "))
    }

    return path.event, nil
})
```

The error message should:
- Quote the unexpected value for clarity
- Show the source state
- List all available values in sorted order
- Be actionable (tells user what values are valid)

### 2. Build-Time Validation

**File**: `/Users/josh/code/sow/.sow/worktrees/77-sdk-branching-support-addbranch-api/cli/internal/sdks/project/builder.go`

The validation in AddBranch (from Task 030) should include:

```go
func (b *ProjectTypeConfigBuilder) AddBranch(
    from sdkstate.State,
    opts ...BranchOption,
) *ProjectTypeConfigBuilder {
    bc := &BranchConfig{from: from}

    for _, opt := range opts {
        opt(bc)
    }

    // Validation 1: Discriminator is required
    if bc.discriminator == nil {
        panic(fmt.Sprintf(
            "AddBranch for state %s: no discriminator provided - use BranchOn() to specify discriminator function",
            from))
    }

    // Validation 2: At least one branch path is required
    if len(bc.branches) == 0 {
        panic(fmt.Sprintf(
            "AddBranch for state %s: no branch paths provided - use When() to define at least one branch path",
            from))
    }

    // Validation 3: Warn if state already has OnAdvance
    if _, exists := b.onAdvance[from]; exists {
        panic(fmt.Sprintf(
            "AddBranch for state %s: state already has OnAdvance determiner - cannot use both AddBranch and OnAdvance on the same state",
            from))
    }

    // Validation 4: Empty discriminator values not allowed
    for value := range bc.branches {
        if value == "" {
            panic(fmt.Sprintf(
                "AddBranch for state %s: empty string is not allowed as a discriminator value",
                from))
        }
    }

    // ... rest of implementation ...
}
```

### 3. Test Coverage for Error Cases

**File**: `/Users/josh/code/sow/.sow/worktrees/77-sdk-branching-support-addbranch-api/cli/internal/sdks/project/branch_test.go`

Add comprehensive error case tests:

```go
func TestDiscriminatorNoMatch(t *testing.T) {
    t.Run("returns error when discriminator returns unmapped value", func(t *testing.T) {
        // Create config with AddBranch
        builder := NewProjectTypeConfigBuilder("test")

        builder.AddBranch(
            sdkstate.State("TestState"),
            BranchOn(func(p *state.Project) string {
                // Return value that has no When clause
                return "unmapped_value"
            }),
            When("expected_value",
                sdkstate.Event("TestEvent"),
                sdkstate.State("NextState"),
            ),
        )

        config := builder.Build()
        proj := createMinimalTestProject(t)

        // Try to determine event - should fail
        event, err := config.DetermineEvent(proj)

        require.Error(t, err)
        assert.Empty(t, event)
        assert.Contains(t, err.Error(), "no branch defined")
        assert.Contains(t, err.Error(), "unmapped_value")
        assert.Contains(t, err.Error(), "expected_value")  // Shows available values
    })

    t.Run("error message lists all available values", func(t *testing.T) {
        // Test with multiple branches to ensure all are listed
        builder := NewProjectTypeConfigBuilder("test")

        builder.AddBranch(
            sdkstate.State("TestState"),
            BranchOn(func(p *state.Project) string { return "invalid" }),
            When("value1", sdkstate.Event("E1"), sdkstate.State("S1")),
            When("value2", sdkstate.Event("E2"), sdkstate.State("S2")),
            When("value3", sdkstate.Event("E3"), sdkstate.State("S3")),
        )

        config := builder.Build()
        proj := createMinimalTestProject(t)

        _, err := config.DetermineEvent(proj)

        require.Error(t, err)
        // Should list all three values
        assert.Contains(t, err.Error(), "value1")
        assert.Contains(t, err.Error(), "value2")
        assert.Contains(t, err.Error(), "value3")
    })
}

func TestAddBranchNoDiscriminator(t *testing.T) {
    t.Run("panics when BranchOn not provided", func(t *testing.T) {
        builder := NewProjectTypeConfigBuilder("test")

        assert.Panics(t, func() {
            builder.AddBranch(
                sdkstate.State("TestState"),
                // Missing BranchOn!
                When("value", sdkstate.Event("E"), sdkstate.State("S")),
            )
        })
    })

    t.Run("panic message explains how to fix", func(t *testing.T) {
        builder := NewProjectTypeConfigBuilder("test")

        defer func() {
            r := recover()
            require.NotNil(t, r)
            msg := fmt.Sprintf("%v", r)
            assert.Contains(t, msg, "no discriminator provided")
            assert.Contains(t, msg, "BranchOn()")
        }()

        builder.AddBranch(
            sdkstate.State("TestState"),
            When("value", sdkstate.Event("E"), sdkstate.State("S")),
        )
    })
}

func TestAddBranchNoBranches(t *testing.T) {
    t.Run("panics when no When clauses provided", func(t *testing.T) {
        builder := NewProjectTypeConfigBuilder("test")

        assert.Panics(t, func() {
            builder.AddBranch(
                sdkstate.State("TestState"),
                BranchOn(func(_ *state.Project) string { return "test" }),
                // Missing When!
            )
        })
    })

    t.Run("panic message explains how to fix", func(t *testing.T) {
        builder := NewProjectTypeConfigBuilder("test")

        defer func() {
            r := recover()
            require.NotNil(t, r)
            msg := fmt.Sprintf("%v", r)
            assert.Contains(t, msg, "no branch paths provided")
            assert.Contains(t, msg, "When()")
        }()

        builder.AddBranch(
            sdkstate.State("TestState"),
            BranchOn(func(_ *state.Project) string { return "test" }),
        )
    })
}

func TestAddBranchConflictWithOnAdvance(t *testing.T) {
    t.Run("panics when state already has OnAdvance", func(t *testing.T) {
        builder := NewProjectTypeConfigBuilder("test")

        // Add OnAdvance first
        builder.OnAdvance(
            sdkstate.State("TestState"),
            func(_ *state.Project) (sdkstate.Event, error) {
                return sdkstate.Event("TestEvent"), nil
            },
        )

        // Try to add AddBranch for same state
        assert.Panics(t, func() {
            builder.AddBranch(
                sdkstate.State("TestState"),
                BranchOn(func(_ *state.Project) string { return "test" }),
                When("test", sdkstate.Event("E"), sdkstate.State("S")),
            )
        })
    })

    t.Run("panic message explains conflict", func(t *testing.T) {
        builder := NewProjectTypeConfigBuilder("test")

        builder.OnAdvance(
            sdkstate.State("TestState"),
            func(_ *state.Project) (sdkstate.Event, error) {
                return sdkstate.Event("TestEvent"), nil
            },
        )

        defer func() {
            r := recover()
            require.NotNil(t, r)
            msg := fmt.Sprintf("%v", r)
            assert.Contains(t, msg, "already has OnAdvance")
            assert.Contains(t, msg, "cannot use both")
        }()

        builder.AddBranch(
            sdkstate.State("TestState"),
            BranchOn(func(_ *state.Project) string { return "test" }),
            When("test", sdkstate.Event("E"), sdkstate.State("S")),
        )
    })
}

func TestAddBranchEmptyDiscriminatorValue(t *testing.T) {
    t.Run("panics when When uses empty string as value", func(t *testing.T) {
        builder := NewProjectTypeConfigBuilder("test")

        assert.Panics(t, func() {
            builder.AddBranch(
                sdkstate.State("TestState"),
                BranchOn(func(_ *state.Project) string { return "" }),
                When("", sdkstate.Event("E"), sdkstate.State("S")),
            )
        })
    })

    t.Run("panic message explains issue", func(t *testing.T) {
        builder := NewProjectTypeConfigBuilder("test")

        defer func() {
            r := recover()
            require.NotNil(t, r)
            msg := fmt.Sprintf("%v", r)
            assert.Contains(t, msg, "empty string")
            assert.Contains(t, msg, "not allowed")
        }()

        builder.AddBranch(
            sdkstate.State("TestState"),
            BranchOn(func(_ *state.Project) string { return "" }),
            When("", sdkstate.Event("E"), sdkstate.State("S")),
        )
    })
}

func TestDiscriminatorReturnsEmptyString(t *testing.T) {
    t.Run("returns helpful error when discriminator returns empty string", func(t *testing.T) {
        // This is different from validation - discriminator might legitimately
        // return empty string at runtime (e.g., no data available yet)
        builder := NewProjectTypeConfigBuilder("test")

        builder.AddBranch(
            sdkstate.State("TestState"),
            BranchOn(func(p *state.Project) string {
                // Return empty string (e.g., data not ready)
                return ""
            }),
            When("ready", sdkstate.Event("E"), sdkstate.State("S")),
        )

        config := builder.Build()
        proj := createMinimalTestProject(t)

        _, err := config.DetermineEvent(proj)

        require.Error(t, err)
        assert.Contains(t, err.Error(), "no branch defined")
        // Empty string should be quoted for clarity
        assert.Contains(t, err.Error(), `""`)
    })
}
```

### 4. Helper for Creating Minimal Test Projects

**File**: `/Users/josh/code/sow/.sow/worktrees/77-sdk-branching-support-addbranch-api/cli/internal/sdks/project/branch_test.go`

Add a test helper for creating minimal projects:

```go
// createMinimalTestProject creates a minimal project for testing
func createMinimalTestProject(t *testing.T) *state.Project {
    t.Helper()

    return &state.Project{
        ProjectState: projectschema.ProjectState{
            Name:   "test-project",
            Type:   "test",
            Branch: "test-branch",
            Phases: map[string]projectschema.PhaseState{},
            Metadata: map[string]any{},
            Statechart: projectschema.StatechartState{
                Current_state: "TestState",
                Updated_at:    time.Now(),
            },
        },
    }
}
```

## Acceptance Criteria

- [ ] Discriminator error messages include:
  - The unexpected value (quoted)
  - The source state
  - All available values (sorted, comma-separated)
- [ ] Build-time validation panics with helpful messages for:
  - Missing discriminator (explains to use BranchOn)
  - No branch paths (explains to use When)
  - Conflict with existing OnAdvance
  - Empty string as discriminator value
- [ ] All error case tests pass:
  - TestDiscriminatorNoMatch (unmapped value at runtime)
  - TestAddBranchNoDiscriminator (missing BranchOn)
  - TestAddBranchNoBranches (missing When)
  - TestAddBranchConflictWithOnAdvance (both AddBranch and OnAdvance)
  - TestAddBranchEmptyDiscriminatorValue (empty string in When)
  - TestDiscriminatorReturnsEmptyString (empty at runtime)
- [ ] Error messages are actionable (tell user how to fix)
- [ ] Code follows existing error handling patterns
- [ ] No breaking changes to existing functionality

## Technical Details

### Panic vs Error Return

**Use panic for build-time errors**:
- Missing discriminator
- No branch paths
- Conflict with OnAdvance
- Empty discriminator values

Rationale: These are programming errors that should never reach production. Panicking early during config building helps catch bugs in development.

**Use error return for runtime errors**:
- Discriminator returns unmapped value

Rationale: This could legitimately happen if project state is in an unexpected condition (e.g., corrupted data, race condition). The system should handle gracefully and allow recovery.

### Error Message Best Practices

1. **Be specific**: "no branch defined for discriminator value "staging"" not "branch not found"
2. **Show context**: Include the state name and available values
3. **Be actionable**: Explain how to fix ("use BranchOn() to specify discriminator")
4. **Quote strings**: Use "value" not value for clarity
5. **Sort lists**: Make output deterministic for testing

### Validation Order

1. Check discriminator exists
2. Check at least one branch path exists
3. Check for OnAdvance conflict
4. Check for empty discriminator values

This order ensures the most common errors are caught first with the clearest messages.

### Testing Edge Cases

Test both the panic message content and the fact that it panics:

```go
assert.Panics(t, func() {
    // Code that should panic
})

// Separately, test the message
defer func() {
    r := recover()
    msg := fmt.Sprintf("%v", r)
    assert.Contains(t, msg, "expected substring")
}()
```

## Relevant Inputs

### Implementation File (Modify)

- `/Users/josh/code/sow/.sow/worktrees/77-sdk-branching-support-addbranch-api/cli/internal/sdks/project/builder.go` - Enhanced validation in AddBranch

### Test File (Extend)

- `/Users/josh/code/sow/.sow/worktrees/77-sdk-branching-support-addbranch-api/cli/internal/sdks/project/branch_test.go` - Add error case tests

### Pattern Reference

- `/Users/josh/code/sow/.sow/worktrees/77-sdk-branching-support-addbranch-api/cli/internal/sdks/project/builder_test.go` - See how existing tests use assert.Panics
- `/Users/josh/code/sow/.sow/worktrees/77-sdk-branching-support-addbranch-api/cli/internal/sdks/project/config.go` - See DetermineEvent for error handling patterns

### Documentation

- `/Users/josh/code/sow/.sow/worktrees/77-sdk-branching-support-addbranch-api/.sow/project/context/issue-77.md` - Error handling requirements (section 4.4)
- `/Users/josh/code/sow/.sow/worktrees/77-sdk-branching-support-addbranch-api/.sow/knowledge/designs/sdk-addbranch-api.md` - Section 12.1 for error handling decisions

## Examples

### Error Message Example (Runtime)

```
Error: no branch defined for discriminator value "unknown" from state ReviewActive
(available values: "fail", "pass")
```

This tells the developer:
- What value was returned ("unknown")
- Which state had the problem (ReviewActive)
- What values are valid ("fail", "pass")

### Error Message Example (Build-Time)

```
panic: AddBranch for state ReviewActive: no discriminator provided -
use BranchOn() to specify discriminator function
```

This tells the developer:
- Which state has the problem (ReviewActive)
- What's wrong (no discriminator)
- How to fix (use BranchOn())

### Test Example

```go
func TestDiscriminatorNoMatch(t *testing.T) {
    builder := NewProjectTypeConfigBuilder("test")

    builder.AddBranch(
        sdkstate.State("TestState"),
        BranchOn(func(p *state.Project) string {
            return "unexpected"  // Not in any When clause
        }),
        When("expected", sdkstate.Event("E"), sdkstate.State("S")),
    )

    config := builder.Build()
    proj := createMinimalTestProject(t)

    _, err := config.DetermineEvent(proj)

    require.Error(t, err)
    assert.Contains(t, err.Error(), `"unexpected"`)
    assert.Contains(t, err.Error(), `"expected"`)
}
```

## Dependencies

- Task 030 (AddBranch builder method) - MUST be complete
  - This task enhances the validation and error handling from Task 030

## Constraints

### Backwards Compatibility

- Existing code without AddBranch must continue working
- Error handling doesn't affect projects not using AddBranch
- Panic behavior is acceptable for config errors (consistent with SDK)

### Performance

- Validation happens at build time (negligible impact)
- Error message construction only happens on error path
- Sorting available values is O(n log n) but n is small (typically 2-5 branches)

### User Experience

- Error messages must be helpful for developers
- Messages should guide users to correct fixes
- Include enough context to debug without source code

## Success Criteria

This task is complete when:

1. All validation is implemented with helpful panic messages
2. Runtime errors include available values in sorted order
3. All error case tests pass
4. Error messages are clear and actionable
5. Code follows existing error handling patterns
6. No regressions in existing functionality

After this task, the AddBranch API is robust and production-ready. Task 050 will add introspection methods for CLI integration.
